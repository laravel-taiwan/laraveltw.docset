<!doctype html>

<html lang="zh">

<head>
    <title>Laravel - 為網頁藝術家創造的 PHP 框架</title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9,chrome=1">
    <meta name="author" content="Taylor Otwell">
    <meta name="description" content="Laravel - The PHP framework for web artisans.">
    <meta name="keywords" content="laravel, php, framework, web, artisans, taylor otwell">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="../favicon.png%3Fv=2">

    <link href="../assets/css/styles.css" rel="stylesheet">

    <!-- fonts -->
    <script src="http://use.edgefonts.net/source-sans-pro:n3,i3,n4,i4,n6,i6,n7,i7.js"></script>
    <script src="http://use.edgefonts.net/source-code-pro.js"></script>

    <!--[if IE]><link href="assets/css/ie.css" rel="stylesheet" type="text/css"><![endif]-->

    <!-- HTML5 elements in less than IE9, yes please! -->
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

    <!-- If less than IE8 add some JS for the webfont icons -->
    <!--[if lt IE 8]><script src="assets/js/ie_font.js"></script><![endif]-->

        <script>
        var _gaq=[['_setAccount','UA-54753797-1'],['_trackPageview']];
        (function(d,t){
            var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)
        }(document,'script'));
    </script>
    
</head>

<body id="index" class="page">

    <!--[if lt IE 7]>
        <p>Your browser is <em>ancient!</em> <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience this site.</p>
    <![endif]-->

    <div id="wrapper">

    <header id="header" role="header">
    <div class="boxed">
        <div id="tagline">
            <h1>中文文件</h1>
        </div>

        <div id="version">
            <ul class="nolist">
                                    <li class="">
                        <a href="master.html" title="Dev">Dev</a>
                    </li>
                                    <li class="current">
                        <a href="../docs.1.html" title="4.2">4.2</a>
                    </li>
                                    <li class="">
                        <a href="4.1.html" title="4.1">4.1</a>
                    </li>
                                    <li class="">
                        <a href="4.0.html" title="4.0">4.0</a>
                    </li>
                            </ul>
        </div>
    </div>
</header>

<nav id="primary">
    <div class="boxed">
        <div id="logo-head">
            <a href="../index.html"><img src="../assets/img/logo-head.png" alt="Laravel"></a>
        </div>
        <ul class="primary-nav-ul">
            <li><a href="../index.html">歡迎</a></li>
            <li class="current-item"><a href="../docs.1.html" title="Documentation">文件</a></li>
            <li><a href="http://laracasts.com">Laracasts</a></li>
            <li><a href="https://forge.laravel.com">Forge</a></li>
            <li><a href="../api/4.2.html" title="Laravel Framework API">API</a></li>
            <li><a href="https://github.com/laravel/laravel" title="Github">Github</a></li>
            <li><a href="http://twitter.com/laravelphp" title="Laravel on Twitter">Twitter</a></li>
        </ul>
        <a href="eloquent.html#" class="show-primary-nav">選單</a>
    </div>
</nav>

<div id="content">

    <section id="documentation">
        <article class="boxed">

            <ul class="version-picker--mobile nolist">
                                <li class="">
                    <a href="master.html" title="Dev">Dev</a>
                </li>
                                <li class="current">
                    <a href="../docs.1.html" title="4.2">4.2</a>
                </li>
                                <li class="">
                    <a href="4.1.html" title="4.1">4.1</a>
                </li>
                                <li class="">
                    <a href="4.0.html" title="4.0">4.0</a>
                </li>
                            </ul>
            <a href="eloquent.html#" class="docs-show" data-show-text="目錄導覽" data-hide-text="關閉">目錄導覽</a>

            <nav id="docs">
                <ul>
<li>前言
<ul>
<li><a href="introduction.html">介紹</a></li>
<li><a href="quick.html">快速開始</a></li>
<li><a href="releases.html">發行說明</a></li>
<li><a href="upgrade.html">升級導引</a></li>
</ul></li>
<li>開始學習
<ul>
<li><a href="installation.html">安裝</a></li>
<li><a href="configuration.html">設定</a></li>
<li><a href="homestead.html">莊園(封裝)</a></li>
<li><a href="lifecycle.html">請求的生命週期</a></li>
<li><a href="routing.html">路由</a></li>
<li><a href="requests.html">請求與輸入</a></li>
<li><a href="responses.html">視圖與回應</a></li>
<li><a href="controllers.html">控制器</a></li>
<li><a href="errors.html">錯誤與日誌</a></li>
</ul></li>
<li>深度體驗
<ul>
<li><a href="security.html">認證</a></li>
<li><a href="billing.html">交易</a></li>
<li><a href="cache.html">快取</a></li>
<li><a href="extending.html">核心擴展</a></li>
<li><a href="events.html">事件</a></li>
<li><a href="facades.html">Facades</a></li>
<li><a href="html.html">表單與 HTML</a></li>
<li><a href="helpers.html">輔助方法</a></li>
<li><a href="ioc.html">IoC 容器</a></li>
<li><a href="localization.html">在地化</a></li>
<li><a href="mail.html">郵件</a></li>
<li><a href="packages.html">資源包開發</a></li>
<li><a href="pagination.html">分頁</a></li>
<li><a href="queues.html">隊列</a></li>
<li><a href="security.html">安全性</a></li>
<li><a href="session.html">Session</a></li>
<li><a href="ssh.html">SSH</a></li>
<li><a href="templates.html">模板</a></li>
<li><a href="testing.html">單元測試</a></li>
<li><a href="validation.html">驗證</a></li>
</ul></li>
<li>資料庫
<ul>
<li><a href="database.html">基本用法</a></li>
<li><a href="queries.html">查詢架構器</a></li>
<li><a href="eloquent.html">Eloquent ORM</a></li>
<li><a href="schema.html">結構生成器</a></li>
<li><a href="migrations.html">遷移與資料填充</a></li>
<li><a href="redis.html">Redis</a></li>
</ul></li>
<li>Artisan 命令列工具
<ul>
<li><a href="artisan.html">概覽</a></li>
<li><a href="commands.html">開發</a></li>
</ul></li>
</ul>
            </nav>

            <div id="docs-content">
                <h1>Eloquent ORM</h1>
<ul>
<li><a href="eloquent.html#introduction">介紹</a></li>
<li><a href="eloquent.html#basic-usage">基本用法</a></li>
<li><a href="eloquent.html#mass-assignment">Mass Assignment</a></li>
<li><a href="eloquent.html#insert-update-delete">新增，修改，刪除</a></li>
<li><a href="eloquent.html#soft-deleting">軟刪除（ Soft Deleting ）</a></li>
<li><a href="eloquent.html#timestamps">時間戳記</a></li>
<li><a href="eloquent.html#query-scopes">範圍查詢</a></li>
<li><a href="eloquent.html#relationships">關聯</a></li>
<li><a href="eloquent.html#querying-relations">關聯查詢</a></li>
<li><a href="eloquent.html#eager-loading">預載入（ Eager Loading ）</a></li>
<li><a href="eloquent.html#inserting-related-models">新增關聯模型</a></li>
<li><a href="eloquent.html#touching-parent-timestamps">更新上層模型時間戳</a></li>
<li><a href="eloquent.html#working-with-pivot-tables">操作樞紐表</a></li>
<li><a href="eloquent.html#collections">Collections</a></li>
<li><a href="eloquent.html#accessors-and-mutators">存取器和修改器</a></li>
<li><a href="eloquent.html#date-mutators">日期轉換器</a></li>
<li><a href="eloquent.html#model-events">模型事件</a></li>
<li><a href="eloquent.html#model-observers">模型觀察者</a></li>
<li><a href="eloquent.html#converting-to-arrays-or-json">轉換陣列 / JSON</a></li>
</ul>
<p><a name="introduction"></a></p>
<h2>介紹</h2>
<p>Laravel 的 Eloquent ORM 提供了漂亮、簡潔的 ActiveRecord 實作來和資料庫互動。每個資料表會和一個對應的「模型」互動。</p>
<p>在開始之前，記得把 <code>app/config/database.php</code> 裡的資料庫連線設定好。</p>
<p><a name="basic-usage"></a></p>
<h2>基本用法</h2>
<p>先從建立一個 Eloquent 模型開始。模型通常放在 <code>app/models</code> 目錄下，但是你可以將它們放在任何地方，只要可以根據 <code>composer.json</code> 被自動載入。</p>
<h4>定義一個 Eloquent 模型</h4>
<pre><code>class User extends Eloquent {}</code></pre>
<p>注意我們並沒有告訴 Eloquent <code>User</code> 模型會使用哪個資料表。若沒有特別指定，預設會自動對應名稱為「類別名稱的小寫複數形態」的資料表。所以，在上面的例子中，Eloquent 會假設 <code>User</code> 將把資料存在 <code>users</code> 資料表。可以在類別裡定義 <code>table</code> 屬性自定要對應的資料表。</p>
<pre><code>class User extends Eloquent {

    protected $table = 'my_users';

}</code></pre>
<blockquote>
<p><strong>注意：</strong> Eloquent 也會假設每個資料表都有一個欄位名稱為 <code>id</code> 的主鍵。你可以在類別裡定義 <code>primaryKey</code> 屬性覆寫這個預設。同樣的，你也可以定義 <code>connection</code> 屬性，指定模型需要的資料庫連線。</p>
</blockquote>
<p>定義好模型之後，你就可以從資料表新增及取得資料了。注意預設上，在資料表裡需要有 <code>updated_at</code> 和 <code>created_at</code> 兩個欄位。如果你不想設定或自動更新這兩個欄位，將類別裡的 <code>$timestamps</code> 屬性設為 <code>false</code>。</p>
<h4>取出所有模型資料</h4>
<pre><code>$users = User::all();</code></pre>
<h4>根據主鍵取出一筆資料</h4>
<pre><code>$user = User::find(1);

var_dump($user-&gt;name);</code></pre>
<blockquote>
<p><strong>提示：</strong> 所有 <a href="queries.html">查詢產生器</a>裡的方法，查詢 Eloquent 模型時也可以使用。</p>
</blockquote>
<h4>根據主鍵取出一筆資料或拋出例外</h4>
<p>有時你可能想要在找不到模型資料時拋出例外，以捕捉例外讓 <code>App::error</code> 處理並顯示 404 頁面。</p>
<pre><code>$model = User::findOrFail(1);

$model = User::where('votes', '&gt;', 100)-&gt;firstOrFail();</code></pre>
<p>要註冊錯誤處理，可以監聽 <code>ModelNotFoundException</code></p>
<pre><code>use Illuminate\Database\Eloquent\ModelNotFoundException;

App::error(function(ModelNotFoundException $e)
{
    return Response::make('Not Found', 404);
});</code></pre>
<h4>Eloquent 模型結合查詢語法</h4>
<pre><code>$users = User::where('votes', '&gt;', 100)-&gt;take(10)-&gt;get();

foreach ($users as $user)
{
    var_dump($user-&gt;name);
}</code></pre>
<h4>Eloquent 聚合查詢</h4>
<p>當然，你也可以使用查詢產生器的聚合查詢方法。</p>
<pre><code>$count = User::where('votes', '&gt;', 100)-&gt;count();</code></pre>
<p>如果沒辦法使用流暢的介面產生出查詢語句，也可以使用 <code>whereRaw</code>：</p>
<pre><code>$users = User::whereRaw('age &gt; ? and votes = 100', array(25))-&gt;get();</code></pre>
<h4>切分查詢</h4>
<p>如果你要處理非常多（數千筆）Eloquent 查詢結果，使用 <code>chunk</code> 方法可以讓你順利作業而不會吃掉記憶體：</p>
<pre><code>User::chunk(200, function($users)
{
    foreach ($users as $user)
    {
        //
    }
});</code></pre>
<p>傳到方法裡的第一個參數表示每次「切分」要取出的資料數量。第二個參數的閉合函數會在每次取出資料時被呼叫。</p>
<h4>指定查詢時連線資料庫</h4>
<p>你也可以指定在執行 Eloquent 查詢時要使用哪個資料庫連線。只要使用 <code>on</code> 方法：</p>
<pre><code>$user = User::on('connection-name')-&gt;find(1);</code></pre>
<p><a name="mass-assignment"></a></p>
<h2>Mass Assignment</h2>
<p>在建立一個新的模型時，你把屬性資料陣列傳入建構子，這些屬性值會經由 mass-assignment 存成模型資料。這非常方便，然而，當盲目地將使用者輸入存到模型時，可能會造成嚴重的安全議題。如果盲目的存入使用者輸入，使用者可以隨意的修改<strong>任何</strong>以及<strong>所有</strong>模型屬性。基於這個理由，所有 Eloquent 模型預設會防止 mass-assignment。</p>
<p>在模型裡設定 <code>fillable</code> 或 <code>guarded</code> 屬性作為開始。</p>
<h4>定義模型 Fillable 屬性</h4>
<p><code>fillable</code> 屬性指定了哪些欄位 mass-assignable。可以設定在類別裡或是建立實例後設定。</p>
<pre><code>class User extends Eloquent {

    protected $fillable = array('first_name', 'last_name', 'email');

}</code></pre>
<p>在上面的範例裡，只有三個屬性 mass-assignable。</p>
<h4>定義模型 Guarded 屬性</h4>
<p><code>guarded</code> 與 <code>fillable</code> 相反，是作為「黑名單」而不是「白名單」：</p>
<pre><code>class User extends Eloquent {

    protected $guarded = array('id', 'password');

}</code></pre>
<blockquote>
<p><strong>注意：</strong> 使用 <code>guarded</code> 時，<code>Input::get()</code> 或任何使用者可以控制的未過濾資料，永遠不應該傳入 <code>save</code> 或 <code>update</code> 方法，因為沒有在「黑名單」內的欄位可能被更新。</p>
</blockquote>
<h4>阻擋所有屬性被 Mass Assignment</h4>
<p>上面的範例中，<code>id</code> 和 <code>password</code> 屬性<strong>不會</strong>被 mass assigned，而所有其他的屬性則是 mass assignable。你也可以使用 guard 屬性阻擋<strong>所有</strong>屬性被 mass assignment：</p>
<pre><code>protected $guarded = array('*');</code></pre>
<p><a name="insert-update-delete"></a></p>
<h2>新增，更新，刪除</h2>
<p>要從模型新增一筆資料到資料庫，只要建立一個模型實例並呼叫 <code>save</code> 方法即可。</p>
<h4>儲存新的模型資料</h4>
<pre><code>$user = new User;

$user-&gt;name = 'John';

$user-&gt;save();</code></pre>
<blockquote>
<p><strong>注意：</strong> 通常 Eloquent 模型主鍵值會自動遞增。但是你若想自定主鍵，將 <code>incrementing</code> 屬性設成 <code>false</code>。</p>
</blockquote>
<p>也可以使用 <code>create</code> 方法存入新的模型資料，新增完後會回傳新增的模型實例。但是在新增前，需要先在模型類別裡設定好 <code>fillable</code> 或 <code>guarded</code> 屬性，因為 Eloquent 預設會防止 mass-assignment。</p>
<p>在新模型資料被儲存或新增後，若模型有自動遞增主鍵，可以從物件取得 <code>id</code> 屬性值：</p>
<pre><code>$insertedId = $user-&gt;id;</code></pre>
<h4>在模型裡設定 Guarded 屬性</h4>
<pre><code>class User extends Eloquent {

    protected $guarded = array('id', 'account_id');

}</code></pre>
<h4>使用模型的 Create 方法</h4>
<pre><code>// 在資料庫建立一筆新的使用者...
$user = User::create(array('name' =&gt; 'John'));

// 以屬性找使用者，若沒有則新增並取得新的實例...
$user = User::firstOrCreate(array('name' =&gt; 'John'));

// 以屬性找使用者，若沒有則建立新的實例...
$user = User::firstOrNew(array('name' =&gt; 'John'));</code></pre>
<h4>更新取出的模型</h4>
<p>要更新模型，可以取出它，更改屬性值，然後使用 <code>save</code> 方法：</p>
<pre><code>$user = User::find(1);

$user-&gt;email = 'john@foo.com';

$user-&gt;save();</code></pre>
<h4>儲存模型和關聯資料</h4>
<p>有時你可能不只想要儲存模型本身，也想要儲存關聯的資料。你可以使用 <code>push</code> 方法達到目的：</p>
<pre><code>$user-&gt;push();</code></pre>
<p>你可以結合查詢語句，批次更新模型：</p>
<pre><code>$affectedRows = User::where('votes', '&gt;', 100)-&gt;update(array('status' =&gt; 2));</code></pre>
<blockquote>
<p><strong>注意：</strong> 若使用 Eloquent 查詢產生器批次更新模型，則不會觸發模型事件。</p>
</blockquote>
<h4>刪除模型</h4>
<p>要刪除模型，只要使用實例呼叫 <code>delete</code> 方法：</p>
<pre><code>$user = User::find(1);

$user-&gt;delete();</code></pre>
<h4>依主鍵值刪除模型</h4>
<pre><code>User::destroy(1);

User::destroy(array(1, 2, 3));

User::destroy(1, 2, 3);</code></pre>
<p>當然，你也可以結合查詢語句批次刪除模型：</p>
<pre><code>$affectedRows = User::where('votes', '&gt;', 100)-&gt;delete();</code></pre>
<h4>只更新模型的時間戳</h4>
<p>如果你只想要更新模型的時間戳，你可以使用 <code>touch</code> 方法：</p>
<pre><code>$user-&gt;touch();</code></pre>
<p><a name="soft-deleting"></a></p>
<h2>軟刪除</h2>
<p>軟刪除了一筆模型資料後，資料並不是真的從資料庫被移除了。而是會設定 <code>deleted_at</code> 時間戳。要讓模型使用軟刪除功能，只要在模型類別裡加入 <code>SoftDeletingTrait</code>：</p>
<pre><code>use Illuminate\Database\Eloquent\SoftDeletingTrait;

class User extends Eloquent {

    use SoftDeletingTrait;

    protected $dates = ['deleted_at'];

}</code></pre>
<p>要加入 <code>deleted_at</code> 欄位到資料表，可以在遷移檔裡使用 <code>softDeletes</code> 方法：</p>
<pre><code>$table-&gt;softDeletes();</code></pre>
<p>現在當你使用模型呼叫 <code>delete</code> 方法時，<code>deleted_at</code> 欄位會被更新成現在的時間戳。在查詢使用軟刪除功能的模型時，被「刪除」的模型資料不會出現在查詢結果裡。</p>
<h4>強制查詢軟刪除資料</h4>
<p>要強制讓已被軟刪除的模型資料出現在查詢結果裡，在查詢時使用 <code>withTrashed</code> 方法：</p>
<pre><code>$users = User::withTrashed()-&gt;where('account_id', 1)-&gt;get();</code></pre>
<p><code>withTrashed</code> 也可以用在關聯查詢：</p>
<pre><code>$user-&gt;posts()-&gt;withTrashed()-&gt;get();</code></pre>
<p>如果你<strong>只想</strong>查詢被軟刪除的模型資料，可以使用 <code>onlyTrashed</code> 方法：</p>
<pre><code>$users = User::onlyTrashed()-&gt;where('account_id', 1)-&gt;get();</code></pre>
<p>要把被軟刪除的模型資料恢復，使用 <code>restore</code> 方法：</p>
<pre><code>$user-&gt;restore();</code></pre>
<p>你也可以結合查詢語句使用 <code>restore</code>：</p>
<pre><code>User::withTrashed()-&gt;where('account_id', 1)-&gt;restore();</code></pre>
<p>如同 <code>withTrashed</code>，<code>restore</code> 方法也可以用在關聯物件：</p>
<pre><code>$user-&gt;posts()-&gt;restore();</code></pre>
<p>如果想要真的從模型資料庫刪除，使用 <code>forceDelete</code> 方法：</p>
<pre><code>$user-&gt;forceDelete();</code></pre>
<p><code>forceDelete</code> 方法也可以用在關聯物件：</p>
<pre><code>$user-&gt;posts()-&gt;forceDelete();</code></pre>
<p>要確認模型是否被軟刪除了，可以使用 <code>trashed</code> 方法：</p>
<pre><code>if ($user-&gt;trashed())
{
    //
}</code></pre>
<p><a name="timestamps"></a>
<a name="timestamps"></a></p>
<h2>時間戳</h2>
<p>預設 Eloquent 會自動維護資料表的 <code>created_at</code> 和 <code>updated_at</code> 欄位。只要把這兩個「時間戳」欄位加到資料表，Eloquent 就會處理剩下的工作。如果不想讓 Eloquent 自動維護這些欄位，把下面的屬性加到模型類別裡：</p>
<h4>關閉自動更新時間戳</h4>
<pre><code>class User extends Eloquent {

    protected $table = 'users';

    public $timestamps = false;

}</code></pre>
<h4>自定時間戳格式</h4>
<p>如果想要自定時間戳格式，可以在模型類別裡覆寫 <code>getDateFormat</code> 方法：</p>
<pre><code>class User extends Eloquent {

    protected function getDateFormat()
    {
        return 'U';
    }

}</code></pre>
<p><a name="query-scopes"></a></p>
<h2>範圍查詢</h2>
<h4>定義範圍查詢</h4>
<p>範圍查詢可以讓你輕鬆的重複利用模型的查詢邏輯。要設定範圍查詢，只要定義有 <code>scope</code> 前綴的模型方法：</p>
<pre><code>class User extends Eloquent {

    public function scopePopular($query)
    {
        return $query-&gt;where('votes', '&gt;', 100);
    }

    public function scopeWomen($query)
    {
        return $query-&gt;whereGender('W');
    }

}</code></pre>
<h4>使用範圍查詢</h4>
<pre><code>$users = User::popular()-&gt;women()-&gt;orderBy('created_at')-&gt;get();</code></pre>
<h4>動態範圍查詢</h4>
<p>有時你可能想要定義可接受參數的範圍查詢方法。只要把參數加到方法裡：</p>
<pre><code>class User extends Eloquent {

    public function scopeOfType($query, $type)
    {
        return $query-&gt;whereType($type);
    }

}</code></pre>
<p>然後把參數值傳到範圍查詢方法呼叫裡：</p>
<pre><code>$users = User::ofType('member')-&gt;get();</code></pre>
<p><a name="relationships"></a></p>
<h2>關聯</h2>
<p>當然，你的資料表很可能跟另一張表相關聯。例如，一篇部落格文章可能有很多評論，或是一張訂單跟下單客戶相關聯。Eloquent 讓管理和處理這些關聯變得很容易。Laravel 有很多種關聯種類：</p>
<ul>
<li><a href="eloquent.html#one-to-one">一對一</a></li>
<li><a href="eloquent.html#one-to-many">一對多</a></li>
<li><a href="eloquent.html#many-to-many">多對多</a></li>
<li><a href="eloquent.html#has-many-through">遠層一對多關聯</a></li>
<li><a href="eloquent.html#polymorphic-relations">多型關聯</a></li>
<li><a href="eloquent.html#many-to-many-polymorphic-relations">多型的多對多關聯</a></li>
</ul>
<p><a name="one-to-one"></a></p>
<h3>一對一</h3>
<h4>定義一對一關聯</h4>
<p>一對一關聯是很基本的關聯。例如一個 <code>User</code> 模型會對應到一個 <code>Phone</code>。在 Eloquent 裡可以像下面這樣定義關聯：</p>
<pre><code>class User extends Eloquent {

    public function phone()
    {
        return $this-&gt;hasOne('Phone');
    }

}</code></pre>
<p>傳到 <code>hasOne</code> 方法裡的第一個參數是關聯模型的類別名稱。定義好關聯之後，就可以使用 Eloquent 的 <a href="eloquent.html#dynamic-properties">動態屬性</a> 取得關聯物件：</p>
<pre><code>$phone = User::find(1)-&gt;phone;</code></pre>
<p>SQL 會執行如下語句：</p>
<pre><code>select * from users where id = 1

select * from phones where user_id = 1</code></pre>
<p>注意，Eloquent 假設對應的關聯模型資料表裡，外鍵名稱是基於模型名稱。在這個例子裡，預設 <code>Phone</code> 模型資料表會以 <code>user_id</code> 作為外鍵。如果想要更改這個預設，可以傳入第二個參數到 <code>hasOne</code> 方法裡。更進一步，你可以傳入第三個參數，指定關聯的外鍵要對應到本身的哪個欄位：</p>
<pre><code>return $this-&gt;hasOne('Phone', 'foreign_key');

return $this-&gt;hasOne('Phone', 'foreign_key', 'local_key');</code></pre>
<h4>定義相對的關聯</h4>
<p>要在 <code>Phone</code> 模型裡定義相對的關聯，可以使用 <code>belongsTo</code> 方法：</p>
<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User');
    }

}</code></pre>
<p>在上面的例子裡，Eloquent 預設會使用 <code>phones</code> 資料表的 <code>user_id</code> 欄位查詢關聯。如果想要自己指定外鍵欄位，可以在 <code>belongsTo</code> 方法裡傳入第二個參數：</p>
<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User', 'local_key');
    }

}</code></pre>
<p>除此之外，也可以傳入第三個參數指定要參照上層資料表的哪個欄位：</p>
<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User', 'local_key', 'parent_key');
    }

}</code></pre>
<p><a name="one-to-many"></a></p>
<h3>一對多</h3>
<p>一對多關聯的例子像是，一篇部落格文章可能「有很多」評論。可以像這樣定義關聯：</p>
<pre><code>class Post extends Eloquent {

    public function comments()
    {
        return $this-&gt;hasMany('Comment');
    }

}</code></pre>
<p>現在可以經由 <a href="eloquent.html#dynamic-properties">動態屬性</a> 取得文章的評論：</p>
<pre><code>$comments = Post::find(1)-&gt;comments;</code></pre>
<p>如果需要增加更多條件限制，可以在呼叫 <code>comments</code> 方法後面串接查詢條件方法：</p>
<pre><code>$comments = Post::find(1)-&gt;comments()-&gt;where('title', '=', 'foo')-&gt;first();</code></pre>
<p>同樣的，你可以傳入第二個參數到 <code>hasMany</code> 方法更改預設的外鍵名稱。以及，如同 <code>hasOne</code> 關聯，可以指定本身的對應欄位：</p>
<pre><code>return $this-&gt;hasMany('Comment', 'foreign_key');

return $this-&gt;hasMany('Comment', 'foreign_key', 'local_key');</code></pre>
<h4>定義相對的關聯</h4>
<p>要在 <code>Comment</code> 模型定義相對的關聯，使用 <code>belongsTo</code> 方法：</p>
<pre><code>class Comment extends Eloquent {

    public function post()
    {
        return $this-&gt;belongsTo('Post');
    }

}</code></pre>
<p><a name="many-to-many"></a></p>
<h3>多對多</h3>
<p>多對多關聯更為複雜。這種關聯的例子如，一個使用者（ user ）可能用有很多身份（ role ），而一種身份可能很多使用者都有。例如很多使用者都是「管理者」。多對多關聯需要用到三個資料表：<code>users</code>、<code>roles</code> 和 <code>role_user</code>。<code>role_user</code> 樞紐表命名是以相關聯的兩個模型資料表，依照字母順序命名，樞紐表裡面應該要有 <code>user_id</code> 和 <code>role_id</code> 欄位。</p>
<p>可以使用 <code>belongsToMany</code> 方法定義多對多關係：</p>
<pre><code>class User extends Eloquent {

    public function roles()
    {
        return $this-&gt;belongsToMany('Role');
    }

}</code></pre>
<p>現在我們可以從 <code>User</code> 模型取得 roles：</p>
<pre><code>$roles = User::find(1)-&gt;roles;</code></pre>
<p>如果不想使用預設的樞紐資料表命名方式，可以傳遞資料表名稱作為 <code>belongsToMany</code> 方法的第二個參數：</p>
<pre><code>return $this-&gt;belongsToMany('Role', 'user_roles');</code></pre>
<p>也可以更改預設的關聯欄位名稱：</p>
<pre><code>return $this-&gt;belongsToMany('Role', 'user_roles', 'user_id', 'foo_id');</code></pre>
<p>當然，也可以在 <code>Role</code> 模型定義相對的關聯：</p>
<pre><code>class Role extends Eloquent {

    public function users()
    {
        return $this-&gt;belongsToMany('User');
    }

}</code></pre>
<p><a name="has-many-through"></a></p>
<h3>遠層一對多關聯</h3>
<p>「遠層一對多關聯」提供了方便簡短的方法，可以經由多層間的關聯取得遠層的關聯。例如，一個 <code>Country</code> 模型可能透過 <code>Users</code> 關聯到很多 <code>Posts</code> 模型。 資料表間的關係可能看起來如下：</p>
<pre><code>countries
    id - integer
    name - string

users
    id - integer
    country_id - integer
    name - string

posts
    id - integer
    user_id - integer
    title - string</code></pre>
<p>雖然 <code>posts</code> 資料表本身沒有 <code>country_id</code> 欄位，但 <code>hasManyThrough</code> 方法讓我們可以使用 <code>$country-&gt;posts</code> 取得 country 的 posts。我們可以定義以下關聯：</p>
<pre><code>class Country extends Eloquent {

    public function posts()
    {
        return $this-&gt;hasManyThrough('Post', 'User');
    }

}</code></pre>
<p>如果想要手動指定關聯的欄位名稱，可以傳入第三和第四個參數到方法裡：</p>
<pre><code>class Country extends Eloquent {

    public function posts()
    {
        return $this-&gt;hasManyThrough('Post', 'User', 'country_id', 'user_id');
    }

}</code></pre>
<p><a name="polymorphic-relations"></a></p>
<h3>多型關聯</h3>
<p>多型關聯可以用一個簡單的關聯方法，就讓一個模型同時關聯多個模型。例如，你可能想讓 photo 模型同時和一個 staff 或 order 模型關聯。可以定義關聯如下：</p>
<pre><code>class Photo extends Eloquent {

    public function imageable()
    {
        return $this-&gt;morphTo();
    }

}

class Staff extends Eloquent {

    public function photos()
    {
        return $this-&gt;morphMany('Photo', 'imageable');
    }

}

class Order extends Eloquent {

    public function photos()
    {
        return $this-&gt;morphMany('Photo', 'imageable');
    }

}</code></pre>
<h4>取得多型關聯物件</h4>
<p>現在我們可以從 staff 或 order 模型取得多型關聯物件：</p>
<pre><code>$staff = Staff::find(1);

foreach ($staff-&gt;photos as $photo)
{
    //
}</code></pre>
<h4>取得多型關聯物件的擁有者</h4>
<p>然而，多型關聯真正神奇的地方，在於要從 <code>Photo</code> 模型取得 staff 或 order 物件時：</p>
<pre><code>$photo = Photo::find(1);

$imageable = $photo-&gt;imageable;</code></pre>
<p><code>Photo</code> 模型裡的 <code>imageable</code> 關聯會回傳 <code>Staff</code> 或 <code>Order</code> 實例，取決于這是哪一種模型擁有的照片。</p>
<h4>多型關聯的資料表結構</h4>
<p>為了理解多型關聯的運作機制，來看看它們的資料表結構：</p>
<pre><code>staff
    id - integer
    name - string

orders
    id - integer
    price - integer

photos
    id - integer
    path - string
    imageable_id - integer
    imageable_type - string</code></pre>
<p>要注意的關鍵是 <code>photos</code> 資料表的 <code>imageable_id</code> 和 <code>imageable_type</code>。在上面的例子裡，ID 欄位會包含 staff 或 order 的 ID，而 type 是擁有者的模型類別名稱。這就是讓 ORM 在取得 <code>imageable</code> 關聯物件時，決定要哪一種模型物件的機制。</p>
<p><a name="many-to-many-polymorphic-relations"></a></p>
<h3>多型的多對多關聯</h3>
<h4>多型的多對多關聯資料表結構</h4>
<p>除了一般的多型關聯，也可以使用多對多的多型關聯。例如，部落格的 <code>Post</code> 和 <code>Video</code> 模型可以共用多型的 <code>Tag</code> 關聯模型。首先，來看看資料表結構：</p>
<pre><code>posts
    id - integer
    name - string

videos
    id - integer
    name - string

tags
    id - integer
    name - string

taggables
    tag_id - integer
    taggable_id - integer
    taggable_type - string</code></pre>
<p>現在，我們準備好設定模型關聯了。<code>Post</code> 和 <code>Video</code> 模型都可以經由 <code>tags</code> 方法建立 <code>morphToMany</code> 關聯：</p>
<pre><code>class Post extends Eloquent {

    public function tags()
    {
        return $this-&gt;morphToMany('Tag', 'taggable');
    }

}</code></pre>
<p>在 <code>Tag</code> 模型裡針對每一種關聯建立一個方法：</p>
<pre><code>class Tag extends Eloquent {

    public function posts()
    {
        return $this-&gt;morphedByMany('Post', 'taggable');
    }

    public function videos()
    {
        return $this-&gt;morphedByMany('Video', 'taggable');
    }

}</code></pre>
<p><a name="querying-relations"></a></p>
<h2>關聯查詢</h2>
<h4>根據關聯條件查詢</h4>
<p>在取得模型資料時，你可能想要以關聯模型作為查詢限制。例如，你可能想要取得所有「至少有一篇評論」的部落格文章。可以使用 <code>has</code> 方法達成目的：</p>
<pre><code>$posts = Post::has('comments')-&gt;get();</code></pre>
<p>也可以指定運算子和數量：</p>
<pre><code>$posts = Post::has('comments', '&gt;=', 3)-&gt;get();</code></pre>
<p>如果想要更進階，可以使用 <code>whereHas</code> 和 <code>orWhereHas</code> 方法，在 <code>has</code> 查詢裡設置「where」條件：</p>
<pre><code>$posts = Post::whereHas('comments', function($q)
{
    $q-&gt;where('content', 'like', 'foo%');

})-&gt;get();</code></pre>
<p><a name="dynamic-properties"></a></p>
<h3>動態屬性</h3>
<p>Eloquent 可以經由動態屬性取得關聯物件。Eloquent 會自動進行關聯查詢，而且會很聰明的知道應該要使用 <code>get</code>（用在一對多關聯）或是 <code>first</code> （用在一對一關聯）方法。可以經由和「關聯方法名稱相同」的動態屬性取得物件。例如，像是下面的模型物件 <code>$phone</code>：</p>
<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User');
    }

}

$phone = Phone::find(1);</code></pre>
<p>或是像下面這樣印出使用者的 email：</p>
<pre><code>echo $phone-&gt;user()-&gt;first()-&gt;email;</code></pre>
<p>可以簡寫如下：</p>
<pre><code>echo $phone-&gt;user-&gt;email;</code></pre>
<blockquote>
<p><strong>注意：</strong> 若取得的是許多關聯物件，會返回 <code>Illuminate\Database\Eloquent\Collection</code> 物件：</p>
</blockquote>
<p><a name="eager-loading"></a></p>
<h2>預載入</h2>
<p>預載入是用來減少 N + 1 查詢問題。例如，一個 <code>Book</code> 模型資料會關聯到一個 <code>Author</code>。關聯會像下面這樣定義：</p>
<pre><code>class Book extends Eloquent {

    public function author()
    {
        return $this-&gt;belongsTo('Author');
    }

}</code></pre>
<p>現在考慮下面的程式碼：</p>
<pre><code>foreach (Book::all() as $book)
{
    echo $book-&gt;author-&gt;name;
}</code></pre>
<p>上面的迴圈會執行一次查詢取回所有資料表上的書籍，然而每本書籍都會執行一次查詢取得作者。所以若我們有 25 本書，就會進行 26 次查詢。</p>
<p>很幸運地，我們可以使用預載入大量減少查詢次數。使用 <code>with</code> 方法指定想要預載入的關聯物件：</p>
<pre><code>foreach (Book::with('author')-&gt;get() as $book)
{
    echo $book-&gt;author-&gt;name;
}</code></pre>
<p>現在，上面的迴圈總共只會執行兩次查詢：</p>
<pre><code>select * from books

select * from authors where id in (1, 2, 3, 4, 5, ...)</code></pre>
<p>使用預載入可以大量增進程式效能。</p>
<p>當然，也可以同時載入多種關聯：</p>
<pre><code>$books = Book::with('author', 'publisher')-&gt;get();</code></pre>
<p>甚至可以預載入巢狀關聯：</p>
<pre><code>$books = Book::with('author.contacts')-&gt;get();</code></pre>
<p>上面的例子中，<code>author</code> 關聯會被預載入，author 的 <code>contacts</code> 關聯也會被預載入。</p>
<h3>預載入條件限制</h3>
<p>有時你可能想要預載入關聯，同時也想要指定載入時的查詢限制。下面有一個範例：</p>
<pre><code>$users = User::with(array('posts' =&gt; function($query)
{
    $query-&gt;where('title', 'like', '%first%');

}))-&gt;get();</code></pre>
<p>上面的例子裡，我們預載入了 user 的 posts 關聯，並限制條件為 post 的 title 欄位需包含「first」。</p>
<p>當然，預載入的閉合函數裡不一定只能加上條件限制，也可以加上排序：</p>
<pre><code>$users = User::with(array('posts' =&gt; function($query)
{
    $query-&gt;orderBy('created_at', 'desc');

}))-&gt;get();</code></pre>
<h3>延遲預載入</h3>
<p>也可以直接從模型的 collection 預載入關聯物件。這對於需要根據情況決定是否載入關聯物件時，或是跟快取一起使用時很有用。</p>
<pre><code>$books = Book::all();

$books-&gt;load('author', 'publisher');</code></pre>
<p><a name="inserting-related-models"></a></p>
<h2>新增關聯模型</h2>
<h4>附加一個關聯模型</h4>
<p>你常常會需要加入新的關聯模型。例如新增一個 comment 到 post。除了手動設定模型的 <code>post_id</code> 外鍵，也可以從上層的 <code>Post</code> 模型新增關聯的 comment：</p>
<pre><code>$comment = new Comment(array('message' =&gt; 'A new comment.'));

$post = Post::find(1);

$comment = $post-&gt;comments()-&gt;save($comment);</code></pre>
<p>上面的例子裡，新增的 comment <code>post_id</code> 欄位會被自動設定。</p>
<p>如果想要同時新增很多關聯模型：</p>
<pre><code>$comments = array(
    new Comment(array('message' =&gt; 'A new comment.')),
    new Comment(array('message' =&gt; 'Another comment.')),
    new Comment(array('message' =&gt; 'The latest comment.'))
);

$post = Post::find(1);

$post-&gt;comments()-&gt;saveMany($comments);</code></pre>
<h3>從屬關聯模型 ( Belongs To )</h3>
<p>要更新 <code>belongsTo</code> 關聯時，可以使用 <code>associate</code> 方法。這個方法會設定子模型的外鍵：</p>
<pre><code>$account = Account::find(10);

$user-&gt;account()-&gt;associate($account);

$user-&gt;save();</code></pre>
<h3>新增多對多關聯模型 ( Many To Many )</h3>
<p>你也可以新增多對多的關聯模型。讓我們繼續使用 <code>User</code> 和 <code>Role</code> 模型作為範例。我們可以使用 <code>attach</code> 方法簡單地把 roles 附加給一個 user：</p>
<h4>附加多對多模型</h4>
<pre><code>$user = User::find(1);

$user-&gt;roles()-&gt;attach(1);</code></pre>
<p>也可以傳入要存在樞紐表中的屬性陣列：</p>
<pre><code>$user-&gt;roles()-&gt;attach(1, array('expires' =&gt; $expires));</code></pre>
<p>當然，有 <code>attach</code> 就會有相反的 <code>detach</code>：</p>
<pre><code>$user-&gt;roles()-&gt;detach(1);</code></pre>
<h4>使用 Sync 方法同時附加一個以上多對多關聯</h4>
<p>你也可以使用 <code>sync</code> 方法附加關聯模型。<code>sync</code> 方法會把根據 ID 陣列把關聯存到樞紐表。附加完關聯後，樞紐表裡的模型只會關聯到 ID 陣列裡的 id：</p>
<pre><code>$user-&gt;roles()-&gt;sync(array(1, 2, 3));</code></pre>
<h4>Sync 時在樞紐表加入額外資料</h4>
<p>也可以在把每個 ID 加入樞紐表時，加入其他欄位的資料：</p>
<pre><code>$user-&gt;roles()-&gt;sync(array(1 =&gt; array('expires' =&gt; true)));</code></pre>
<p>有時你可能想要使用一個指令，在建立新模型資料的同時附加關聯。可以使用 <code>save</code> 方法達成目的：</p>
<pre><code>$role = new Role(array('name' =&gt; 'Editor'));

User::find(1)-&gt;roles()-&gt;save($role);</code></pre>
<p>上面的例子裡，新的 <code>Role</code> 模型物件會在儲存的同時關聯到 user 模型。也可以傳入屬性陣列把資料加到關聯資料表：</p>
<pre><code>User::find(1)-&gt;roles()-&gt;save($role, array('expires' =&gt; $expires));</code></pre>
<p><a name="touching-parent-timestamps"></a></p>
<h2>更新上層時間戳</h2>
<p>當模型 <code>belongsTo</code> 另一個模型，比方說一個 <code>Comment</code> 屬於一個 <code>Post</code>，如果能在子模型被更新時，更新上層的時間戳，這將會很有用。例如，當 <code>Comment</code> 模型更新時，你可能想要能夠同時自動更新 <code>Post</code> 的 <code>updated_at</code> 時間戳。Eloquent 讓事情變得很簡單。只要在子關聯的類別裡，把關聯方法名稱加入 <code>touches</code> 屬性即可：</p>
<pre><code>class Comment extends Eloquent {

    protected $touches = array('post');

    public function post()
    {
        return $this-&gt;belongsTo('Post');
    }

}</code></pre>
<p>現在，當你更新 <code>Comment</code> 時，對應的 <code>Post</code> 會自動更新 <code>updated_at</code> 欄位：</p>
<pre><code>$comment = Comment::find(1);

$comment-&gt;text = 'Edit to this comment!';

$comment-&gt;save();</code></pre>
<p><a name="working-with-pivot-tables"></a></p>
<h2>使用樞紐表</h2>
<p>如你所知，要操作多對多關聯需要一個中間的資料表。Eloquent 提供了一些有用的方法可以和這張表互動。例如，假設 <code>User</code> 物件關聯到很多 <code>Role</code> 物件。取出這些關聯物件時，我們可以在關聯模型上取得 <code>pivot</code> 資料表的資料：</p>
<pre><code>$user = User::find(1);

foreach ($user-&gt;roles as $role)
{
    echo $role-&gt;pivot-&gt;created_at;
}</code></pre>
<p>注意我們取出的每個 <code>Role</code> 模型物件會自動給一個 <code>pivot</code> 屬性。這屬性包含了樞紐表的模型資料，可以像一般的 Eloquent 模型一樣使用。</p>
<p>預設 <code>pivot</code> 物件只會有關聯鍵的屬性。如果你想讓 <code>pivot</code> 可以包含其他樞紐表的欄位，可以在定義關聯方法時指定那些欄位：</p>
<pre><code>return $this-&gt;belongsToMany('Role')-&gt;withPivot('foo', 'bar');</code></pre>
<p>現在可以在 <code>Role</code> 模型的 <code>pivot</code> 物件上取得 <code>foo</code> 和 <code>bar</code> 屬性了。</p>
<p>如果你想要可以自動維護樞紐表的 <code>created_at</code> 和 <code>updated_at</code> 時間戳，在定義關聯方法時加上 <code>withTimestamps</code> 方法：</p>
<pre><code>return $this-&gt;belongsToMany('Role')-&gt;withTimestamps();</code></pre>
<h4>刪除樞紐表的關聯資料</h4>
<p>要刪除模型在樞紐表的所有關聯資料，可以使用 <code>detach</code> 方法：</p>
<pre><code>User::find(1)-&gt;roles()-&gt;detach();</code></pre>
<p>注意，如上的操作不會移除 <code>roles</code> 資料表裡面的資料，只會移除樞紐表裡的關聯資料。</p>
<h4>更新樞紐表的資料</h4>
<p>有時你只想更新樞紐表的資料，而沒有要移除關聯。如果你想更新樞紐表，可以像下面的例子使用 <code>updateExistingPivot</code> 方法：</p>
<pre><code>User::find(1)-&gt;roles()-&gt;updateExistingPivot($roleId, $attributes);</code></pre>
<h4>自定樞紐模型</h4>
<p>Laravel 允許你自定樞紐模型。要自定模型，首先要建立一個繼承 <code>Eloquent</code> 的「基本」模型類別。在其他的 Eloquent 模型繼承這個自定的基本類別，而不是預設的 <code>Eloquent</code> 。在基本模型類別裡，加入下面的方法回傳自定的樞紐模型實例：</p>
<pre><code>public function newPivot(Model $parent, array $attributes, $table, $exists)
{
    return new YourCustomPivot($parent, $attributes, $table, $exists);
}</code></pre>
<p><a name="collections"></a></p>
<h2>Collections</h2>
<p>所有 Eloquent 查詢回傳的資料，如果結果多於一筆，不管是經由 <code>get</code> 方法或是 <code>relationship</code>，都會轉換成 collection 物件回傳。這個物件實作了 <code>IteratorAggregate</code> PHP 介面，所以可以像陣列一般進行迭代。而 Collections 物件本身還擁有很多有用的方法可以操作模型資料。</p>
<h4>確認 Collection 裡是否包含特定鍵值</h4>
<p>例如，我們可以使用 <code>contains</code> 方法，確認結果資料中，是否包含主鍵為特定值的物件。</p>
<pre><code>$roles = User::find(1)-&gt;roles;

if ($roles-&gt;contains(2))
{
    //
}</code></pre>
<p>Collection 也可以轉換成陣列或 JSON：</p>
<pre><code>$roles = User::find(1)-&gt;roles-&gt;toArray();

$roles = User::find(1)-&gt;roles-&gt;toJson();</code></pre>
<p>如果 collection 被型別轉換成字串，會回傳 JSON 格式：</p>
<pre><code>$roles = (string) User::find(1)-&gt;roles;</code></pre>
<h4>Collections 迭代</h4>
<p>Eloquent collections 裡包含了一些有用的方法可以進行迴圈或是進行過濾：</p>
<pre><code>$roles = $user-&gt;roles-&gt;each(function($role)
{
    //
});</code></pre>
<h4>Collection 過濾</h4>
<p>過濾 collection 時，回呼函數的使用方式和 <a href="http://php.net/manual/en/function.array-filter.php">array_filter</a> 裡一樣。</p>
<pre><code>$users = $users-&gt;filter(function($user)
{
    return $user-&gt;isAdmin();
});</code></pre>
<blockquote>
<p><strong>注意：</strong> 如果要在過濾 collection 之後轉成 JSON，轉換之前先呼叫 <code>values</code> 方法重設陣列的鍵值。</p>
</blockquote>
<h4>迭代傳入 Collection 裡的每個物件到回呼函數</h4>
<pre><code>$roles = User::find(1)-&gt;roles;

$roles-&gt;each(function($role)
{
    //
});</code></pre>
<h4>依照屬性值排序</h4>
<pre><code>$roles = $roles-&gt;sortBy(function($role)
{
    return $role-&gt;created_at;
});</code></pre>
<h4>依照屬性值排序</h4>
<pre><code>$roles = $roles-&gt;sortBy('created_at');</code></pre>
<h4>回傳自定的集合物件</h4>
<p>有時你可能想要回傳自定的集合物件，讓你可以在集合類別裡加入想要的方法。可以在 Eloquent 模型類別裡覆寫 <code>newCollection</code> 方法：</p>
<pre><code>class User extends Eloquent {

    public function newCollection(array $models = array())
    {
        return new CustomCollection($models);
    }

}</code></pre>
<p><a name="accessors-and-mutators"></a></p>
<h2>存取器和修改器</h2>
<h4>定義存取器</h4>
<p>Eloquent 提供了便利的方法，可以在取得或設定屬性時進行轉換。要定義存取器，只要在模型裡加入類似 <code>getFooAttribute</code> 的方法。注意方法名稱應該使用駝峰式大小寫命名，而對應的 database 欄位名稱是底線分隔小寫命名：</p>
<pre><code>class User extends Eloquent {

    public function getFirstNameAttribute($value)
    {
        return ucfirst($value);
    }

}</code></pre>
<p>上面的例子中，<code>first_name</code> 欄位設定了一個存取器。注意傳入方法的參數是原本的欄位資料。</p>
<h4>定義修改器</h4>
<p>修改器的宣告方式很雷同：</p>
<pre><code>class User extends Eloquent {

    public function setFirstNameAttribute($value)
    {
        $this-&gt;attributes['first_name'] = strtolower($value);
    }

}</code></pre>
<p><a name="date-mutators"></a></p>
<h2>日期轉換器</h2>
<p>預設 Eloquent 會把 <code>created_at</code> 和 <code>updated_at</code> 欄位屬性轉換成 <a href="https://github.com/briannesbitt/Carbon">Carbon</a> 實例，它提供了很多有用的方法，並繼承了 PHP 原生的 <code>DateTime</code> 類別。</p>
<p>你可以經由覆寫模型的 <code>getDates</code> 方法，自定哪個欄位可以被自動轉換，或甚至完全不要讓日期轉換成 Carbon：</p>
<pre><code>public function getDates()
{
    return array('created_at');
}</code></pre>
<p>當欄位是表示日期的時候，可以將值設為 UNIX timestamp、日期字串（ <code>Y-m-d</code> ）、日期時間（ date-time ）字串，當然還有 <code>DateTime</code> 或 <code>Carbon</code> 實例。</p>
<p>要完全關閉日期轉換功能，只要從 <code>getDates</code> 方法回傳空陣列即可：</p>
<pre><code>public function getDates()
{
    return array();
}</code></pre>
<p><a name="model-events"></a></p>
<h2>Model Events</h2>
<p>Eloquent 模型有很多事件可以驅動，讓你可以在模型操作的生命週期中不同時間點，使用下列方法綁定事件：<code>creating</code>、<code>created</code>、<code>updating</code>、<code>updated</code>、<code>saving</code>、<code>saved</code>、<code>deleting</code>、<code>deleted</code>、<code>restoring</code>、<code>restored</code>。</p>
<p>當一個物件初次被儲存到資料庫，<code>creating</code> 和 <code>created</code> 事件會被驅動。如果不是新物件而呼叫了 <code>save</code> 方法，<code>updating</code> / <code>updated</code> 事件會被驅動。而兩者的 <code>saving</code> / <code>saved</code> 事件都會被驅動。</p>
<h4>使用事件取消資料庫操作</h4>
<p>如果 <code>creating</code>、<code>updating</code>、<code>saving</code>、<code>deleting</code> 事件回傳 <code>false</code> 的話，就會取消資料庫操作：</p>
<pre><code>User::creating(function($user)
{
    if ( ! $user-&gt;isValid()) return false;
});</code></pre>
<h4>設定模型 Boot 方法</h4>
<p>Eloquent 模型有靜態的 <code>boot</code> 方法，可以使用它方便的註冊事件綁定。</p>
<pre><code>class User extends Eloquent {

    public static function boot()
    {
        parent::boot();

        // Setup event bindings...
    }

}</code></pre>
<p><a name="model-observers"></a></p>
<h2>模型觀察者</h2>
<p>要整合模型的事件處理，可以註冊一個模型觀察者。觀察者類別裡要設定對應模型事件的方法。例如，觀察者類別裡可能有 <code>creating</code>、<code>updating</code>、<code>saving</code> 方法，還有其他對應模型事件名稱的方法：</p>
<p>例如，一個模型觀察者類別可能看起來如下：</p>
<pre><code>class UserObserver {

    public function saving($model)
    {
        //
    }

    public function saved($model)
    {
        //
    }

}</code></pre>
<p>可以使用 <code>observe</code> 方法註冊一個觀察者實例：</p>
<pre><code>User::observe(new UserObserver);</code></pre>
<p><a name="converting-to-arrays-or-json"></a></p>
<h2>轉換成陣列 / JSON</h2>
<h4>將模型資料轉成陣列</h4>
<p>建立 JSON API 時，你可能常常需要把模型和關聯物件轉換成陣列或 JSON。所以 Eloquent 裡已經包含了這些方法。要把模型和已載入的關聯物件轉成陣列，可以使用 <code>toArray</code> 方法：</p>
<pre><code>$user = User::with('roles')-&gt;first();

return $user-&gt;toArray();</code></pre>
<p>記得也可以把模型 collection 轉換成陣列：</p>
<pre><code>return User::all()-&gt;toArray();</code></pre>
<h4>把模型轉換成 JSON</h4>
<p>要把模型轉換成 JSON，可以使用 <code>toJson</code> 方法：</p>
<pre><code>return User::find(1)-&gt;toJson();</code></pre>
<h4>從路由回傳模型</h4>
<p>注意當模型或 collection 被型別轉換成字串，會自動轉換成 JSON 格式，這意味著你可以直接從路由回傳 Eloquent 物件！</p>
<pre><code>Route::get('users', function()
{
    return User::all();
});</code></pre>
<h4>轉換成陣列或 JSON 時隱藏屬性</h4>
<p>有時你可能想要限制能出現在陣列或 JSON 格式的屬性資料，比如密碼。只要在模型裡增加 <code>hidden</code> 屬性即可：</p>
<pre><code>class User extends Eloquent {

    protected $hidden = array('password');

}</code></pre>
<blockquote>
<p><strong>注意：</strong> 要隱藏關聯資料，要使用關聯的<strong>方法</strong>名稱，而不是動態存取的屬性名稱。</p>
</blockquote>
<p>此外，可以使用 <code>visible</code> 屬性定義白名單：</p>
<pre><code>protected $visible = array('first_name', 'last_name');</code></pre>
<p><a name="array-appends"></a>
有時候你可能想要增加不存在資料庫欄位的屬性資料。這時候只要定義一個存取器即可：</p>
<pre><code>public function getIsAdminAttribute()
{
    return $this-&gt;attributes['admin'] == 'yes';
}</code></pre>
<p>定義好存取器之後，再把對應的屬性名稱加到模型裡的 <code>appends</code> 屬性：</p>
<pre><code>protected $appends = array('is_admin');</code></pre>
<p>把屬性加到 <code>appends</code> 陣列之後，在模型資料轉換成陣列或 JSON 格式時就會有對應的值。</p>
            </div>

        </article>
    </section>

</div>

<footer id="foot" class="textcenter">
    <div class="boxed">

        <nav id="secondary">
            <div id="logo-foot">
                <a href="../index.html"><img src="../assets/img/logo-foot.png" alt="Laravel"></a>
            </div>
            <ul>
            <li><a href="../api/4.2.html" title="Laravel Framework API">API</a></li>
            <li><a href="https://github.com/laravel/laravel" title="Github">Github</a></li>
            <li><a href="http://twitter.com/laravelphp" title="Laravel on Twitter">Twitter</a></li>
                <li><a href="../index.html">歡迎</a></li>
                <li class="current-item"><a href="../docs.1.html" title="Documentation">文件</a></li>
                <li><a href="http://laracasts.com">Laracasts</a></li>
                <li><a href="https://forge.laravel.com">Forge</a></li>
                <li><a href="../api/4.2.html" title="Laravel Framework API">API</a></li>
                <li><a href="https://github.com/laravel/laravel" title="Github">Github</a></li>
                <li><a href="http://twitter.com/laravelphp" title="Laravel on Twitter">Twitter</a></li>
            </ul>
        </nav>

    </div>
</footer>

<div id="top">
    <a href="eloquent.html#index" title="Back to the top">
        <i class="icon-chevron-up"></i>
    </a>
</div>


    </div>

    <section id="copyright" class="textcenter">
        <div class="boxed">
            <div class="animated slideInLeft">
                Laravel is a trademark of Taylor Otwell.<br class="br-mobile--footer">
                Copyright &copy; <a href="http://twitter.com/taylorotwell" title="Taylor Otwell" target="_blank">Taylor Otwell</a>.<br class="br-mobile--footer">
                Website built with &hearts; <a href="http://ikreativ.com/" title="iKreativ" target="_blank">iKreativ</a>;<br class="br-mobile--footer">
                responsive by <a href="http://tighten.co/" title="Tighten Co." target="_blank">Tighten Co.</a>;<br class="br-mobile--footer">
                translate by <a href="../index.html" title="Laravel Taiwan" target="_blank">Laravel Taiwan</a>
            </div>
        </div>
    </section>

    <script src="../assets/js/bundle.js"></script>

</body>
</html>
